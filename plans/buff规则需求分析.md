# Buff规则需求与当前实现差距分析

> **重要发现**: 经过深入分析代码，发现YOLO11模型**已经具备点亮状态识别能力**。模型只输出点亮的扇叶，未点亮的扇叶不会被检测到。`light_num`变量表示当前检测到的点亮扇叶数量。

## 1. 规则5.5.2核心需求总结

### 1.1 能量机关旋转机制

| 能量机关类型 | 状态 | 转速模型 |
|------------|------|---------|
| 小能量机关 | 所有状态 | 恒定 1/3π rad/s ≈ 1.047 rad/s |
| 大能量机关 | 未激活/已激活 | 恒定 1/3π rad/s ≈ 1.047 rad/s |
| 大能量机关 | 正在激活 | spd = a·sin(ω·t) + b<br/>a ∈ [0.780, 1.045]<br/>ω ∈ [1.884, 2.000]<br/>b = 2.090 - a |

**参数重置规则**: 每次大能量机关进入可激活状态时，所有参数重置（t=0，a和ω重置为取值范围内任意值）

### 1.2 能量机关状态

| 状态 | 描述 |
|-----|------|
| 未激活 | 所有装甲模块熄灭 |
| 正在激活 | 随机点亮装甲模块，有流动灯效 |
| 已激活 | 5组灯臂全部点亮 |
| 激活失败 | 触发失败条件后重置 |

### 1.3 小能量机关激活机制

1. **激活流程**:
   - 随机点亮5块装甲模块中的1个
   - 2.5秒内击中任意一个被点亮的装甲模块
   - 击中后该灯臂完全点亮，随机点亮其余4块中的1个
   - 以此类推，直到5块全部点亮

2. **激活失败条件**:
   - 未能在2.5秒内击中点亮的装甲模块
   - 击中非随机点亮的装甲模块

3. **时间限制**:
   - 进入正在激活状态20秒后仍未激活，恢复为未激活状态

### 1.4 大能量机关激活机制

1. **激活流程**:
   - 随机点亮5块装甲模块中的2个
   - 2.5秒内击中任意一个被点亮的装甲模块
   - 击中后该灯臂改变灯效，1秒内可以击中另一个被点亮的装甲模块
   - 不论是否成功，能量机关重新随机点亮5块中的2个
   - 需要激活5组灯臂才能完全激活

2. **激活失败条件**:
   - 未能在2.5秒内击中点亮的装甲模块
   - 击中非随机点亮的装甲模块

3. **时间限制**:
   - 进入正在激活状态20秒后仍未激活，恢复为未激活状态

### 1.5 增益效果

| 能量机关类型 | 增益效果 |
|------------|---------|
| 小能量机关 | 25%防御增益，持续45秒；额外100%经验（最多1200点） |
| 大能量机关 | 根据平均环数提供攻击/防御/热量冷却增益；750点经验分给存活机器人 |

## 2. 当前实现能力分析

### 2.1 已实现功能 ✓

#### 2.1.1 旋转速度预测

**小能量机关** ([`SmallTarget`](tasks/auto_buff/buff_target.hpp:71)):
```cpp
const double SMALL_W = CV_PI / 3;  // ≈ 1.047 rad/s
```
- ✓ 恒定角速度模型
- ✓ 角度与规则一致

**大能量机关** ([`BigTarget`](tasks/auto_buff/buff_target.hpp:94)):
```cpp
spd = a * sin(w * t + fi) + 2.09 - a
```
- ✓ 正弦速度模型
- ✓ 参数范围匹配规则要求
  - a ∈ [0.78, 1.045] ✓
  - w ∈ [1.884, 2.000] ✓
  - b = 2.09 - a ✓
- ✓ 使用RANSAC拟合速度函数

#### 2.1.2 目标检测

**YOLO11检测** ([`YOLO11_BUFF`](tasks/auto_buff/yolo11_buff.hpp:15)):
- ✓ 检测Buff目标
- ✓ 提取5个关键点（扇叶顶点）
- ✓ 置信度筛选和NMS处理

#### 2.1.3 PnP解算

**解算器** ([`Solver`](tasks/auto_buff/buff_solver.hpp:17)):
- ✓ 将2D图像坐标转换为3D世界坐标
- ✓ 计算Buff位姿（yaw, pitch, roll）
- ✓ 计算目标扇叶位置

#### 2.1.4 EKF预测

**扩展卡尔曼滤波** ([`Target`](tasks/auto_buff/buff_target.hpp:33)):
- ✓ 小符线性模型预测
- ✓ 大符非线性模型预测
- ✓ 角度周期性处理
- ✓ 扇叶跳变处理

#### 2.1.5 弹道解算

**瞄准器** ([`Aimer`](tasks/auto_buff/buff_aimer.hpp:19)):
- ✓ 弹道解算
- ✓ 射击时机判断
- ✓ MPC轨迹规划支持

### 2.2 未实现功能 ✗

#### 2.2.1 能量机关状态识别

**缺失功能**:
- ✗ 识别能量机关状态（未激活/正在激活/已激活）
- ✗ 识别被点亮的装甲模块
- ✗ 识别流动灯效
- ✗ 区分小能量机关和大能量机关

**影响**:
- 无法判断当前是否处于激活状态
- 无法选择正确的击打目标（被点亮的装甲模块）
- 无法判断激活进度

#### 2.2.2 激活状态下的旋转策略

**缺失功能**:
- ✗ 区分"正在激活"和"非正在激活"状态
- ✗ 根据状态切换旋转速度模型
  - 非正在激活: 恒定 1/3π rad/s
  - 正在激活: 正弦速度模型

**当前实现**:
```cpp
// BigTarget始终使用正弦速度模型
spd = a * sin(w * t + fi) + 2.09 - a
```

**问题**:
- 非正在激活状态下应使用恒定速度
- 当前实现可能在大能量机关未激活时误用变速模型

#### 2.2.3 击打目标选择

**缺失功能**:
- ✗ 识别被点亮的装甲模块
- ✗ 区分小能量机关（1个）和大能量机关（2个）的点亮数量
- ✗ 优先击打被点亮的装甲模块
- ✗ 避免击中非点亮的装甲模块

**当前实现**:
```cpp
// Buff_Detector::detect() 中
// 仅选择距离上一帧目标最近或图像中心最近的目标
// 未考虑装甲模块是否被点亮
```

**问题**:
- 无法满足规则要求的击打目标选择策略
- 可能击中非点亮的装甲模块导致激活失败

#### 2.2.4 激活进度跟踪

**缺失功能**:
- ✗ 跟踪已激活的灯臂数量
- ✗ 判断激活进度（小能量机关: 0-5，大能量机关: 0-5组）
- ✗ 识别中部灯臂进度指示（大能量机关）

**影响**:
- 无法判断激活是否完成
- 无法根据激活进度调整策略

#### 2.2.5 激活失败检测

**缺失功能**:
- ✗ 检测2.5秒超时
- ✗ 检测击中非点亮装甲模块
- ✗ 检测20秒激活超时

**影响**:
- 无法及时检测激活失败
- 无法在失败后重新开始激活

#### 2.2.6 参数重置机制

**缺失功能**:
- ✗ 检测能量机关进入可激活状态
- ✗ 重置大能量机关参数（t=0, a, ω）
- ✗ 重置激活进度

**影响**:
- 参数可能累积误差
- 无法适应新的激活周期

#### 2.2.7 裁判系统通信

**缺失功能**:
- ✗ 接收裁判系统激活触发信号
- ✗ 接收能量机关状态信息
- ✗ 发送激活完成信号

**影响**:
- 无法自动触发激活
- 无法获取官方状态信息

## 3. 需求差距总结

| 需求 | 当前实现 | 状态 | 优先级 |
|-----|---------|------|-------|
| 小能量机关恒定速度预测 | ✓ 已实现 | 完成 | - |
| 大能量机关变速速度预测 | ✓ 已实现 | 完成 | - |
| 目标检测与定位 | ✓ 已实现 | 完成 | - |
| PnP位姿解算 | ✓ 已实现 | 完成 | - |
| 弹道解算 | ✓ 已实现 | 完成 | - |
| 能量机关状态识别 | ✗ 未实现 | 缺失 | 高 |
| 装甲模块点亮状态识别 | ✗ 未实现 | 缺失 | 高 |
| 激活状态旋转策略切换 | ✗ 未实现 | 缺失 | 高 |
| 击打目标选择（点亮模块） | ✗ 未实现 | 缺失 | 高 |
| 激活进度跟踪 | ✗ 未实现 | 缺失 | 中 |
| 激活失败检测 | ✗ 未实现 | 缺失 | 中 |
| 参数重置机制 | ✗ 未实现 | 缺失 | 中 |
| 裁判系统通信 | ✗ 未实现 | 缺失 | 低 |

## 4. 实现建议

### 4.1 高优先级功能

#### 4.1.1 装甲模块点亮状态识别

**方案1: 基于YOLO11扩展**
- 修改YOLO11模型，增加"点亮状态"分类
- 输出格式: `[cx, cy, ow, oh, score, is_lit, kpt_x1, kpt_y1, ...]`

**方案2: 基于传统图像处理**
- 使用HSV颜色空间提取亮色区域
- 结合关键点位置判断装甲模块是否点亮
- 优势: 无需重新训练模型

**推荐**: 方案2，实现快速，可快速验证

#### 4.1.2 击打目标选择

```cpp
// 在Buff_Detector中添加
class Buff_Detector {
    // ...
    std::vector<FanBlade> select_lit_targets(
        const std::vector<FanBlade>& fanblades,
        PowerRune_type type) {
        std::vector<FanBlade> lit_targets;
        
        if (type == SMALL) {
            // 小能量机关: 选择1个点亮的
            for (const auto& fb : fanblades) {
                if (fb.is_lit) {
                    lit_targets.push_back(fb);
                    break;
                }
            }
        } else {
            // 大能量机关: 选择2个点亮的
            for (const auto& fb : fanblades) {
                if (fb.is_lit && lit_targets.size() < 2) {
                    lit_targets.push_back(fb);
                }
            }
        }
        
        return lit_targets;
    }
};
```

#### 4.1.3 激活状态旋转策略切换

```cpp
// 在BigTarget中添加状态管理
class BigTarget : public Target {
private:
    bool is_activating_ = false;  // 是否正在激活
    
public:
    void set_activating(bool activating) {
        is_activating_ = activating;
    }
    
    void predict(double dt) override {
        if (is_activating_) {
            // 正在激活: 使用正弦速度模型
            spd = a * sin(w * t + fi) + 2.09 - a;
        } else {
            // 非正在激活: 使用恒定速度
            spd = CV_PI / 3;
        }
        // ... 其余预测逻辑
    }
};
```

### 4.2 中优先级功能

#### 4.2.1 激活进度跟踪

```cpp
// 在PowerRune中添加进度字段
class PowerRune {
private:
    int activated_arms_ = 0;  // 已激活的灯臂数量
    int current_group_ = 0;     // 当前激活组（大能量机关）
    
public:
    void update_progress(int newly_activated) {
        activated_arms_ += newly_activated;
        if (activated_arms_ >= 5) {
            current_group_++;
            activated_arms_ = 0;
        }
    }
    
    bool is_fully_activated() const {
        return current_group_ >= 5;
    }
};
```

#### 4.2.2 激活失败检测

```cpp
// 在Buff_Detector中添加超时检测
class Buff_Detector {
private:
    std::chrono::steady_clock::time_point last_hit_time_;
    const double HIT_TIMEOUT = 2.5;  // 2.5秒
    const double ACTIVATE_TIMEOUT = 20.0;  // 20秒
    
public:
    bool check_activation_failure() {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = tools::delta_time(now, last_hit_time_);
        
        if (elapsed > HIT_TIMEOUT) {
            tools::logger()->warn("Activation failed: hit timeout");
            return true;
        }
        
        return false;
    }
};
```

#### 4.2.3 参数重置机制

```cpp
// 在BigTarget中添加重置方法
class BigTarget : public Target {
public:
    void reset_activation_params() {
        // 重置时间
        lasttime_ = 0;
        
        // 重置参数为初始值
        ekf_.x[7] = 0.9125;  // a
        ekf_.x[8] = 1.942;   // w
        ekf_.x[9] = 0.0;     // fi
        
        // 清空速度拟合历史
        spd_fitter_.clear();
        
        tools::logger()->info("BigTarget activation params reset");
    }
};
```

### 4.3 低优先级功能

#### 4.3.1 裁判系统通信

```cpp
// 在io/cboard中添加裁判系统接口
class CBoard {
public:
    // 接收激活触发信号
    bool receive_activation_trigger();
    
    // 接收能量机关状态
    EnergyRuneState receive_rune_state();
    
    // 发送激活完成信号
    void send_activation_complete();
};
```

## 5. 实现路线图

### 阶段1: 核心功能实现（高优先级）

1. **装甲模块点亮状态识别**
   - 实现基于HSV的点亮状态检测
   - 在FanBlade中添加is_lit字段
   - 测试和验证

2. **击打目标选择**
   - 实现select_lit_targets方法
   - 区分小能量机关（1个）和大能量机关（2个）
   - 集成到detect方法中

3. **激活状态旋转策略切换**
   - 在BigTarget中添加is_activating标志
   - 实现状态切换逻辑
   - 测试恒定速度和变速模型的切换

### 阶段2: 辅助功能实现（中优先级）

1. **激活进度跟踪**
   - 在PowerRune中添加进度字段
   - 实现进度更新逻辑
   - 添加进度可视化

2. **激活失败检测**
   - 实现2.5秒超时检测
   - 实现20秒激活超时检测
   - 添加失败处理逻辑

3. **参数重置机制**
   - 实现reset_activation_params方法
   - 检测激活周期开始
   - 自动触发参数重置

### 阶段3: 完善功能（低优先级）

1. **裁判系统通信**
   - 实现裁判系统接口
   - 添加状态同步逻辑
   - 测试通信稳定性

2. **优化和调试**
   - 性能优化
   - 参数调优
   - 实车测试

## 6. 风险评估

| 风险 | 影响 | 概率 | 缓解措施 |
|-----|------|------|---------|
| 点亮状态识别不准确 | 高 | 中 | 使用多种方法（HSV+深度学习）融合 |
| 击打目标选择错误 | 高 | 中 | 添加置信度筛选和容错机制 |
| 旋转策略切换不及时 | 中 | 低 | 添加状态预测和提前切换 |
| 激活失败检测延迟 | 中 | 低 | 使用高精度计时器 |
| 裁判系统通信不稳定 | 低 | 中 | 添加重试和超时机制 |

## 7. 结论

### 7.1 已实现能力

当前Buff功能在以下方面已经能够满足规则要求：

1. **旋转速度预测** ✓
   - 小能量机关恒定速度（1/3π rad/s）
   - 大能量机关变速速度（spd = a·sin(ω·t) + b）
   - 参数范围匹配规则要求

2. **点亮扇叶识别** ✓
   - YOLO11模型只输出点亮的扇叶
   - [`light_num`](tasks/auto_buff/buff_type.cpp:22)变量记录点亮扇叶数量
   - 支持小符单亮（1个）和大符双亮（2个）的情况

3. **目标检测与定位** ✓
   - YOLO11目标检测
   - PnP位姿解算
   - 弹道解算

### 7.2 未充分利用的能力

虽然系统已经具备点亮扇叶识别能力，但以下功能未充分利用：

1. **能量机关状态判断** ⚠️
   - 未利用`light_num`判断能量机关状态（未激活/正在激活/已激活）

2. **小符/大符激活流程区分** ⚠️
   - 未根据点亮扇叶数量区分小符（1个）和大符（2个）的激活流程

3. **激活进度跟踪** ⚠️
   - 未利用`light_num`的变化跟踪激活进度

4. **激活状态旋转策略切换** ⚠️
   - 未根据激活状态切换旋转速度模型

5. **激活失败检测** ⚠️
   - 未利用`light_num`的变化检测激活失败

6. **参数重置机制** ⚠️
   - 未利用`light_num`的变化检测激活周期开始

### 7.3 完全缺失的功能

1. **裁判系统通信** ✗
   - 未实现与裁判系统的通信接口

### 7.4 建议

当前Buff功能在**旋转速度预测**和**点亮扇叶识别**方面已经能够满足规则要求，但在**能量机关状态管理**、**激活流程控制**等核心功能方面存在明显不足。

建议按照实现路线图，优先完成高优先级功能（状态判断、流程区分、策略切换），然后逐步实现中低优先级功能（进度跟踪、失败检测、参数重置、裁判通信），最终实现完整的能量机关激活系统。

**关键优势**: 系统已经具备点亮扇叶识别能力，只需在此基础上添加状态管理和流程控制逻辑，即可大幅提升激活成功率。
